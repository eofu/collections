package com.myself.pattern.structural.structural3decorator;

/**
 * 需要在运行时动态的给一个对象增加额外的职责时候
 * 需要给一个现有的类增加职责，但是又不想通过继承的方式来实现的时候（应该优先使用组合而非继承），或者通过继承的方式不现实的时候（可能由于排列组合产生类爆炸的问题）。
 */
public class DecoratorTest {
    public static void main(String[] args) {
        // 为了实现类在不修改原始类的基础上进行动态的覆盖或新增方法
        // 采用装饰模式
        // 该实现保持跟原有类的层级关系
        // 装饰器模式是一种特殊的适配器模式

        /*  wrapper decorate
        ======================================================
        装饰器模式                    ｜ 适配器模式
        ----------------------------+-------------------------
        是一种特殊的适配器模式          ｜ 可以不保留层级关系
        ----------------------------+-------------------------
        装饰者和被装饰者都要实现同一个接口｜ 适配者和被适配者没有必然联系，
        目的是为了扩展，依旧保留OOP关系  ｜ 通常采用代理或者继承用来包装。
        ----------------------------+-------------------------
        满足is-a的关系                ｜ 满足has-a的关系
        ----------------------------+-------------------------
        装饰器模式注重的是覆盖和扩展     ｜适配器模式注重的是兼容和转换
        ======================================================
         */
        
    }
}
